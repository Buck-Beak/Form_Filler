================================================================================
              PLAYWRIGHT FORM-FILLER BOT - WORKFLOW DOCUMENTATION
================================================================================

PROJECT OVERVIEW:
-----------------
This is a Telegram-based bot that automates form-filling on websites using 
Playwright browser automation, AI-powered field classification (Google Gemini), 
and user data mapping. The bot is designed to handle complex government and 
institutional forms with anti-bot detection measures.

================================================================================
ARCHITECTURE & FILE STRUCTURE:
================================================================================

The project is modular, split into the following components:

1. main.py                  ‚Üí Telegram bot entry point & orchestration
2. browser_utils.py         ‚Üí Playwright browser setup with stealth features
3. form_extractor.py        ‚Üí Extract form fields from all frames
4. field_classifier.py      ‚Üí AI-based field classification using Gemini
5. form_filler.py           ‚Üí Autofill logic with selector fallbacks
6. config.py                ‚Üí Environment variable configuration
7. forms.json               ‚Üí Database of form URLs and metadata
8. users.json               ‚Üí Database of user data for autofill
9. .env                     ‚Üí Environment secrets (Telegram token, Gemini API key)

================================================================================
DETAILED WORKFLOW:
================================================================================

PHASE 1: BOT INITIALIZATION
----------------------------
File: main.py (if __name__ == "__main__")

1. Load Configuration:
   - Load TELEGRAM_TOKEN and GEMINI_API_KEY from config.py (which reads .env)
   - Initialize Google Generative AI (Gemini) model: gemini-2.5-flash

2. Load Databases:
   - Load forms.json ‚Üí Dictionary of form metadata (name, URL, description)
     Example: {"JEE Main": {"url": "https://jee.nta.ac.in/...", ...}}
   - Load users.json ‚Üí Array of user profiles with telegram_id and personal data
     Example: [{"telegram_id": 123456, "name": "John", "email": "...", ...}]

3. Initialize Data Structures:
   - pending_requests = {} ‚Üí Stores active form-fill requests with unique IDs

4. Start Telegram Bot:
   - Create Telegram Application using ApplicationBuilder
   - Register handlers:
     * /start command ‚Üí start() function
     * Text messages ‚Üí handle_message() function
     * Button callbacks ‚Üí button_handler() function
   - Start polling for updates

================================================================================

PHASE 2: USER INTERACTION (Telegram)
-------------------------------------
File: main.py (start, handle_message)

Step 1: User sends /start command
   ‚Üì
   Bot responds with welcome message explaining how to use it

Step 2: User sends a text message (e.g., "I want to fill JEE form")
   ‚Üì
   Function: handle_message(update, context)
   
   2.1 Extract user information:
       - Get telegram_id from update.message.from_user.id
       - Get user_text from update.message.text
   
   2.2 Form URL Matching:
       - Call get_form_url(user_text)
       - Convert user_text to lowercase
       - Search forms.json for matching form key
       - Return (url, form_key) if found, else (None, None)
   
   2.3 User Data Lookup:
       - Search users.json for user with matching telegram_id
       - If not found ‚Üí Send error message and return
   
   2.4 Create Pending Request:
       - Generate unique request_id = "{telegram_id}_{timestamp}"
       - Store in pending_requests dictionary:
         {
           "url": form_url,
           "form_key": form_name,
           "user_data": user_profile,
           "chat_id": chat_id
         }
   
   2.5 Send Interactive Button:
       - Create InlineKeyboardButton: "üöÄ Open & Auto-Fill Form"
       - Button callback_data: "fill_{request_id}"
       - Send message with form details and button

================================================================================

PHASE 3: BROWSER AUTOMATION TRIGGER
------------------------------------
File: main.py (button_handler)

Step 3: User clicks "Open & Auto-Fill Form" button
   ‚Üì
   Function: button_handler(update, context)
   
   3.1 Validate Request:
       - Extract request_id from callback_data
       - Check if request_id exists in pending_requests
       - If invalid/expired ‚Üí Send error and return
   
   3.2 Retrieve Request Data:
       - url = request["url"]
       - user_data = request["user_data"]
       - form_key = request["form_key"]
       - chat_id = request["chat_id"]
   
   3.3 Update User:
       - Edit button message to show "üîÑ Opening browser..."

================================================================================

PHASE 4: STEALTH BROWSER LAUNCH
--------------------------------
File: browser_utils.py (launch_browser)

Step 4: Initialize Playwright with anti-detection
   ‚Üì
   Function: launch_browser() ‚Üí Returns (playwright, browser, context, page)
   
   4.1 Start Playwright:
       - await async_playwright().start()
   
   4.2 Launch Chromium Browser (headless=False for visibility):
       Browser Arguments (Anti-Detection):
       - --disable-blink-features=AutomationControlled
         ‚Üí Hides the fact that browser is controlled by automation
       - --disable-dev-shm-usage
         ‚Üí Prevents shared memory issues
       - --no-sandbox, --disable-setuid-sandbox
         ‚Üí Bypass sandboxing (required for some environments)
       - --disable-web-security
         ‚Üí Disable CORS restrictions
       - --disable-features=IsolateOrigins,site-per-process
         ‚Üí Disable site isolation for iframe access
   
   4.3 Create Browser Context (Stealth Profile):
       - viewport: 1920x1080 (realistic desktop resolution)
       - user_agent: Chrome 131 on Windows (realistic UA string)
       - locale: en-US
       - timezone_id: Asia/Kolkata
       - permissions: ['geolocation']
       - extra_http_headers: Realistic browser headers including:
         * Accept, Accept-Language, Accept-Encoding
         * Sec-Fetch-* headers (modern browser fingerprint)
         * sec-ch-ua headers (Chrome user agent client hints)
   
   4.4 Create New Page & Inject Stealth Scripts:
       JavaScript Injection (add_init_script):
       - navigator.webdriver ‚Üí undefined (hide automation flag)
       - window.chrome ‚Üí { runtime: {} } (fake Chrome object)
       - navigator.languages ‚Üí ['en-US','en']
       - navigator.platform ‚Üí 'Win32'
   
   4.5 Return:
       - Playwright instance (for cleanup)
       - Browser instance
       - Browser context
       - Page object (ready for automation)

================================================================================

PHASE 5: FORM PAGE NAVIGATION
------------------------------
File: main.py (button_handler - continued)

Step 5: Navigate to form URL
   ‚Üì
   await page.goto(url, wait_until="domcontentloaded", timeout=60000)
   
   5.1 Load Page:
       - Navigate to the form URL
       - Wait until DOM is fully loaded (not necessarily all images/scripts)
       - Timeout: 60 seconds
   
   5.2 Initial Stability Wait:
       - await asyncio.sleep(5)
       - Allow JavaScript frameworks to initialize
       - Wait for dynamic form fields to render
       - Essential for Angular/React/Vue forms

================================================================================

PHASE 6: FORM FIELD EXTRACTION
-------------------------------
File: form_extractor.py (extract_form_fields)

Step 6: Extract all form fields from page and iframes
   ‚Üì
   Function: extract_form_fields(page) ‚Üí Returns list of field dictionaries
   
   6.1 Define JavaScript Extraction Logic:
       JavaScript Code (js_code):
       - Query all visible input elements:
         * input (excluding type=hidden, type=image)
         * textarea
         * select
       
       - For each element, extract:
         * id (field ID attribute)
         * name (field name attribute)
         * placeholder (placeholder text)
         * type (input type or tag name)
         * formcontrolname (Angular-specific attribute)
         * aria-label (accessibility label)
       
       - Label Text Extraction (multi-strategy):
         a) Find <label for="field_id"> (explicit label)
         b) Find nearest parent container (div, td, li, mat-form-field)
            and search for <label> or <mat-label> inside
         c) Fallback to aria-label or placeholder
         d) Clean label: remove asterisks (*), colons (:), trim whitespace
       
       - Visibility Check:
         * getBoundingClientRect() ‚Üí Get element dimensions
         * Only include if width > 0 AND height > 0
       
       - Build field object:
         {
           "id": field_id,
           "name": field_name,
           "placeholder": placeholder,
           "type": field_type,
           "label": label_text,
           "formcontrolname": formcontrolname,
           "aria_label": aria_label
         }
   
   6.2 Extract from Main Frame:
       - await page.evaluate(js_code)
       - Mark all fields with frame: 'main'
       - Add to all_fields list
       - Handle errors (print warning, continue)
   
   6.3 Extract from All Child Frames (iframes):
       - Iterate through page.frames
       - Skip main_frame (already processed)
       - For each frame:
         * await frame.evaluate(js_code)
         * Mark fields with frame: frame.url or frame.name
         * Add to all_fields list
         * Handle errors (print warning, continue)
   
   6.4 Return Aggregated Fields:
       - List of all fields from main frame + all iframes
       - Each field includes frame identifier for later filling
   
   6.5 Retry Logic (in main.py):
       - Try extraction up to 10 times with 1-second intervals
       - Break if fields found
       - Handles slow-loading forms or delayed rendering

================================================================================

PHASE 7: AI-POWERED FIELD CLASSIFICATION
-----------------------------------------
File: field_classifier.py (classify_fields_with_gemini)

Step 7: Use Google Gemini to classify each field
   ‚Üì
   Function: classify_fields_with_gemini(fields, gemini_model) ‚Üí Returns classified fields
   
   7.1 Build Classification Prompt:
       Prompt Structure:
       - Instruction: "You are given form fields from a webpage..."
       - Field Attributes: id, name, placeholder, type, label
       - Categories List:
         * name, email, password, phone, address
         * father_name, mother_name
         * aadhaar_number, date_of_birth, dob
         * assessment_year, pan, mobile
         * other (catch-all)
       - Output Format: JSON array only (no markdown)
       - Include actual field data as JSON
   
   7.2 Send to Gemini:
       - gemini_model.generate_content(prompt)
       - Gemini analyzes field attributes and labels
       - Returns classification in JSON format
   
   7.3 Parse Response:
       - Get raw text from response
       - Remove markdown code fences (```json, ```)
       - Use regex to clean:
         * re.sub(r"^```[a-zA-Z]*\n?", "", raw_text)
         * re.sub(r"```$", "", raw_text)
       - Parse JSON: json.loads(raw_text)
   
   7.4 Error Handling:
       - If JSON parsing fails ‚Üí print error and raw text
       - Return empty list []
   
   7.5 Output Format:
       [
         {"id": "email_field", "name": "user_email", "category": "email"},
         {"id": "phone_input", "name": "mobile_no", "category": "phone"},
         ...
       ]

================================================================================

PHASE 8: INTELLIGENT AUTOFILL
------------------------------
File: form_filler.py (autofill_form)

Step 8: Fill form fields with user data
   ‚Üì
   Function: autofill_form(page, classified_fields, user_data) ‚Üí Returns filled_count
   
   8.1 Key Mapping (Category ‚Üí User Data):
       KEY_MAP = {
         "date_of_birth": "dob",
         "dob": "dob",
         "phone": "mobile",
         "mobile": "mobile",
         "pan": "panAdhaarUserId",
         "aadhaar_number": "panAdhaarUserId",
         "aadhaar": "panAdhaarUserId"
       }
       - Maps AI categories to actual user_data keys
       - Handles synonyms and variations
   
   8.2 For Each Classified Field:
       a) Extract field metadata:
          - field_id, field_name, category, field_frame
       
       b) Map category to user data:
          - data_key = KEY_MAP.get(category, category)
          - value = user_data.get(data_key)
          - If no value ‚Üí Skip field (print diagnostic)
       
       c) Build Selector Candidates (priority order):
          1. #field_id (ID selector)
          2. [name='field_name'] (name attribute)
          3. [formcontrolname='...'] (Angular)
          4. [placeholder='...'] (placeholder)
          5. [aria-label='...'] (accessibility)
       
       d) Locate Target Frame:
          - Default: page.main_frame
          - If field_frame != "main":
            * Search page.frames for matching URL or name
            * Use matched frame as target_frame
       
       e) Try Each Selector (until success):
          For each selector in candidates:
            i)   Locate element: target_frame.locator(selector).first
            ii)  Wait: await asyncio.sleep(0.2)
            iii) Check element exists: await element.count()
            iv)  Check visibility: await element.is_visible()
            v)   Click to focus: await element.click()
            vi)  Wait: await asyncio.sleep(0.1)
            vii) Clear field:
                 - Try: await element.clear()
                 - Fallback: await element.fill("")
            viii) Wait: await asyncio.sleep(0.1)
            ix)  Type value: await element.type(str(value), delay=50)
                 - Types character-by-character with 50ms delay
                 - Mimics human typing behavior
            x)   Log success & break loop
          
          If selector fails ‚Üí Try next selector
          If all selectors fail ‚Üí Log failure
       
       f) Track filled count
   
   8.3 Return Statistics:
       - Total number of successfully filled fields

================================================================================

PHASE 9: USER NOTIFICATION & CLEANUP
-------------------------------------
File: main.py (button_handler - completion)

Step 9: Inform user and manage browser lifecycle
   ‚Üì
   
   9.1 Send Success Message (via Telegram):
       - "‚úÖ Form auto-filled!"
       - "üìä Filled X fields."
       - "üëÄ Please review the form in the browser and submit manually."
       - "The browser will stay open for 5 minutes."
   
   9.2 Keep Browser Open:
       - await asyncio.sleep(300)  # 5 minutes
       - Allows user to review and manually submit
       - User can modify auto-filled data if needed
   
   9.3 Cleanup:
       - await browser.close()
       - await playwright.stop()
       - del pending_requests[request_id]
   
   9.4 Error Handling:
       - Try-except wraps entire automation process
       - On error:
         * Print error to console
         * Send error message to user via Telegram
         * Clean up pending_requests

================================================================================

DATA FLOW DIAGRAM:
================================================================================

User (Telegram)
    |
    | 1. Send message: "Fill JEE form"
    ‚Üì
main.py::handle_message()
    |
    | 2. Lookup form URL in forms.json
    | 3. Lookup user data in users.json
    | 4. Create pending_request
    | 5. Send button to user
    ‚Üì
User clicks button
    ‚Üì
main.py::button_handler()
    |
    | 6. Retrieve request from pending_requests
    ‚Üì
browser_utils.py::launch_browser()
    |
    | 7. Start Playwright
    | 8. Launch Chromium with stealth config
    | 9. Inject anti-detection scripts
    | 10. Return (playwright, browser, context, page)
    ‚Üì
main.py::button_handler() (continued)
    |
    | 11. Navigate to form URL
    | 12. Wait for page load + stability
    ‚Üì
form_extractor.py::extract_form_fields()
    |
    | 13. Run JS extraction on main frame
    | 14. Run JS extraction on all iframes
    | 15. Return aggregated field list
    ‚Üì
field_classifier.py::classify_fields_with_gemini()
    |
    | 16. Build classification prompt
    | 17. Send to Google Gemini API
    | 18. Parse JSON response
    | 19. Return classified fields
    ‚Üì
form_filler.py::autofill_form()
    |
    | 20. For each field:
    |     - Map category to user data
    |     - Build selector candidates
    |     - Locate in correct frame
    |     - Fill with typing delay
    | 21. Return filled count
    ‚Üì
main.py::button_handler() (completion)
    |
    | 22. Send success message to user
    | 23. Keep browser open (5 min)
    | 24. Close browser & cleanup
    ‚Üì
End

================================================================================

KEY FEATURES & DESIGN DECISIONS:
================================================================================

1. STEALTH & ANTI-DETECTION:
   - Disabled webdriver flag
   - Realistic browser fingerprint (UA, headers, viewport)
   - Human-like typing delays
   - Disabled automation-controlled blink features

2. IFRAME SUPPORT:
   - Extracts fields from all frames (not just main)
   - Tracks frame origin for each field
   - Fills fields in correct frame context

3. ROBUST FIELD DETECTION:
   - Multiple label detection strategies
   - Visibility filtering (only visible fields)
   - Support for Angular (formcontrolname), standard HTML, accessibility attributes

4. AI-POWERED CLASSIFICATION:
   - Gemini analyzes field semantics
   - Handles variations in naming conventions
   - Flexible category mapping

5. FAULT TOLERANCE:
   - Retry logic for field extraction (10 attempts)
   - Multiple selector fallbacks per field
   - Graceful error handling with diagnostics

6. USER EXPERIENCE:
   - Interactive Telegram buttons
   - Real-time status updates
   - Browser stays open for manual review
   - Clear success/error messages

7. SECURITY & PRIVACY:
   - Manual login (no password automation)
   - User reviews before submission
   - Environment variables for secrets
   - Local user data storage

8. MAINTAINABILITY:
   - Modular architecture (6 separate files)
   - Clear separation of concerns
   - Comprehensive logging
   - JSON-based configuration

================================================================================

DEPENDENCIES & REQUIREMENTS:
================================================================================

From requirements.txt:
- playwright                ‚Üí Browser automation
- python-telegram-bot       ‚Üí Telegram bot API
- google-generativeai       ‚Üí Gemini AI for classification
- python-dotenv             ‚Üí Environment variable management

Additional Setup:
- Playwright browsers: `playwright install chromium`
- Telegram bot token from BotFather
- Google Gemini API key
- Populated forms.json and users.json

================================================================================

ERROR SCENARIOS & HANDLING:
================================================================================

1. Form Not Found:
   - User message doesn't match any key in forms.json
   - Response: "‚ùå Form not found in my database."

2. User Not Found:
   - telegram_id not in users.json
   - Response: "‚ùå Your user data is not in the database."

3. Page Load Timeout:
   - Form URL doesn't load within 60 seconds
   - Exception caught, error message sent to user

4. Field Extraction Failure:
   - JavaScript errors in frame
   - Retry up to 10 times with 1-second delays
   - Continues with partial extraction

5. Gemini Classification Error:
   - JSON parsing fails
   - Returns empty list, no fields classified
   - Logged to console for debugging

6. Autofill Failures:
   - Field not found with any selector
   - Logged: "‚ùå Could not fill 'category'"
   - Continues to next field (partial fill)

7. Browser Crashes:
   - Playwright errors during automation
   - Exception caught, cleanup performed
   - Error message sent to user

================================================================================

FUTURE ENHANCEMENTS & LIMITATIONS:
================================================================================

Current Limitations:
- Manual login required (by design for security)
- No support for multi-step forms
- No CAPTCHA handling
- No OTP automation
- Single form per request

Potential Improvements:
- Parallel frame extraction for speed
- Configurable delays (speed vs. stealth tradeoff)
- Form submission automation (optional)
- Screenshot capture for diagnostics
- Multi-step form state management
- Support for file uploads
- Custom field mapping per form
- Database integration (replace JSON files)
- Session persistence across requests

================================================================================

TESTING & DEBUGGING:
================================================================================

Debug Artifacts:
- debug_prelogin_main.html  ‚Üí Saved page HTML before login
- debug_postlogin_main.html ‚Üí Saved page HTML after login
- Console logs with emoji indicators:
  * üìÑ Extraction progress
  * ü§ñ Classification progress
  * ‚úÖ Successful fills
  * ‚ö†Ô∏è Warnings/retries
  * ‚ùå Failures

Testing Strategy:
1. Unit testing: Test each module independently
2. Integration testing: Test full workflow with mock forms
3. Live testing: Test on actual government/institutional sites
4. User acceptance: Telegram user testing with real data

================================================================================
END OF WORKFLOW DOCUMENTATION
================================================================================
